---
title: "nuspectral demo"
author: Julien Emile-Geay
date: December 21, 2018
output: github_document
---

First we generate synthetic colored noise with Milankovitch frequencies.
For the background, we use the method of Kirchner, J. W. (2005), Aliasing in 1/fα noise spectra: Origins, consequences, and remedies, Physical Review E, 71(6), 066,110–, doi:10.1103/PhysRevE.71.066110.
```{r}
library(ggplot2)
library(ggthemes)
dt = 2
time = seq(dt,3000,by=dt)
nt = as.numeric(length(time))
nf = nt
y = matrix(nrow = nt, ncol = nf)
alpha = 1 # noise color
fs = 1/dt
f0 = fs/nt
theta = 2*pi*runif(nf)

for(k in 1:nf){
  y[,k] = (f0*k)^(-alpha/2)*sin(2*k*f0*time + theta[k])
}
ys = scale(rowSums(y))  # add up and scale
# add Milankovitch harmonics
periods = c(100,41,23,19)
amp = 1
np = length(periods)
yp = y = matrix(nrow = nt, ncol = np)
for(i in 1:np){
  yp[,i] = amp*sin(2*pi/periods[i]*time)
}

yp = rowSums(yp)  # add up

yt = ys + yp

# plot
ggplot() + geom_line(aes(x=time,y=yt),colour="orange") + ggtitle("Colored Milankovitch noise") + ylab("d18O") + scale_x_continuous(breaks=seq(0,5)) + xlab("Age (ka)") + theme_hc(base_size = 12, base_family = "sans", style = "darkunica", bgcolor = NULL)
```
```{r}
# Define auxiliary functions for plotting
reverselog10_trans <- function(){
  trans <- function(x) -log(x, 10)
  inv <- function(x) 10^(-x)
  return(scales::trans_new("reverselog10-", trans, inv, 
            log_breaks(base = 10), 
            domain = c(1e-100, Inf)))
}
plotSpectraAnnotate = function (p, periods = c(19,23,41,100)){
  #get the x- and y-axis ranges actually used in the graph
  ggp <- ggplot_build(p)
  ylims <- ggp$layout$panel_params[[1]]$y.range # this will break with multiplots... 
  for(per in periods){
    p <- p + annotate("segment", x = per, xend = per, y = 10**(ylims[1]-1), yend = 10**ylims[2],
    colour = "red", alpha = 0.5)
    p <- p +  annotate("text", x = 1.03*per, y = 2*10**ylims[2], label = format(per,digits=2, nsmall=0), colour = "red")
  }
return(p)  
}
```


```{r}
library(geoChronR)
library(nuspectral)
library(astrochron)
library(scales)
# WWZ method
tau = seq(min(time),max(time),length = max(nt %/% 2,5))

#spec.wwz = nuspectral:::nuwavelet_psd(time,yt,sigma=0.01,taus = tau)
load('spec.wwz.Rdata')   # load this to speed things up; TOGGLE for real example
period_range =  c(10, 1000) 
freq = spec.wwz$Frequency
f.low = 1/period_range[2]
f.high = 1/period_range[1]
freq_range = (freq>= f.low & freq<=f.high)


# add power-law fit
specIn = data.frame(cbind(spec.wwz$Frequency, spec.wwz$Power))
resFit = astrochron::pwrLawFit(specIn, dof = 2, flow = f.low, fhigh = f.high, output = 1, genplot = F)
pwrLawFreq = resFit[, 1]
pwrLawLine = resFit[, 4]
CL90  = resFit[, 5]
CL95  = resFit[, 6]
CL99  = resFit[, 7]
# estimate range
m <- floor(log10(min(spec.wwz$Power[freq_range]))) 
M <- ceiling(log10(max(spec.wwz$Power[freq_range]))) 

#geom_line(aes(x=1/f,y=spec.mtmPL$PowerLaw_fit),colour="blue")
  
period_ticks= c(10, 20, 50, 100, 200, 500, 1000)
p <- ggplot() + geom_line(aes(x=1/spec.wwz$Frequency,y=spec.wwz$Power),colour="orange") + 
  theme_hc(base_size = 12, base_family = "sans", style = "darkunica", bgcolor = NULL) + 
  scale_x_continuous(breaks=period_ticks, minor_breaks = NULL, trans=reverselog10_trans(), limits = rev(period_range)) +
  xlab("Period (kyr)") + ylab("Normalized Power") + ggtitle("Colored Milankovitch noise, WWZ, power-law null") +  
  scale_y_log10(limits = c(10^m,10^M)) + 
  geom_line(aes(x=1/pwrLawFreq,y=CL90),colour="white",linetype = 1) +
  geom_line(aes(x=1/pwrLawFreq,y=CL95),colour="white",linetype = 2) +
  geom_line(aes(x=1/pwrLawFreq,y=CL99),colour="white",linetype = 3) +
plotSpectraAnnotate(p)
```

We see four peaks at the frequencies where we put them (nothing short of reassuring) and a background with a 1/f slope (again, reassuring as that's what we put in). Note that the default value of sigma (0.05) would give an overly smooth spectrum. 
Also, you may want to play with the tau vector. Making it sparser will speed things up, though high-frequency variability will be undersampled. It thus requires some careful consideration. Here we choose to skip every other point, as a 4ka interval stil allows to resolve Milankovitch frequencies while not wasting time on high-frequency features, which are pure noise in this demo. 

